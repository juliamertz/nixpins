use crate::{
    fetcher::{Fetcher, Source},
    url::Url,
};
use anyhow::Result;
use regex::{Captures, Regex};
use serde::Deserialize;
use std::{
    collections::{BTreeMap, HashSet},
    io::{Read, Write},
    path::Path,
    process::Stdio,
};

#[derive(Debug, Deserialize)]
pub struct Input {
    url: Url,
    flake: Option<bool>,
}

pub type Inputs = BTreeMap<String, Input>;
pub type Sources = BTreeMap<String, Fetcher>;

/// Data structure of pins.nix
#[derive(Debug, Default, Deserialize)]
pub struct Pins {
    pub inputs: Inputs,
    pub sources: Sources,
}

impl Pins {
    pub fn add(&mut self, url: Url, name: Option<String>, flake: bool) -> Result<()> {
        let name = name.unwrap_or(url.repo.clone());
        if self.inputs.contains_key(&name) {
            anyhow::bail!("Pin already exists of name '{name}'")
        }

        self.inputs.insert(
            name.clone(),
            Input {
                url: url.clone(),
                flake: if flake { Some(true) } else { None },
            },
        );
        log::info!("Adding new input {name} with url {:?}", &url);

        let fetcher = Fetcher::from_url(url.fmt()?.as_str(), flake)?;
        log::info!("Added {name} at {version}", version = fetcher.version());
        self.sources.insert(name, fetcher);
        Ok(())
    }

    pub fn remove(&mut self, name: &str) {
        if self.inputs.remove(name).is_some() {
            log::info!("Removed input for {name}");
        }
        if self.sources.remove(name).is_some() {
            log::info!("Removed source for {name}");
        }
    }

    pub fn update(&mut self, name: &str) -> Result<()> {
        log::info!("Updating {name}...");
        let input = match self.inputs.get(name) {
            Some(pin) => pin,
            None => {
                anyhow::bail!("No pin found of name {name}");
            }
        };

        let fetcher = Fetcher::from_url(
            input.url.fmt()?,
            self.inputs
                .get(name)
                .and_then(|i| i.flake)
                .unwrap_or_default(),
        )?;

        if let Some(prev_fetcher) = self.sources.get(name) {
            if prev_fetcher == &fetcher {
                log::info!("Nothing to do.")
            } else {
                log::info!(
                    "updated {name} to new version:\n  version = '{version}'\n  hash = '{hash}'",
                    version = fetcher.version(),
                    hash = fetcher.hash()
                )
            }
        }

        self.sources.insert(name.to_string(), fetcher);
        Ok(())
    }

    pub fn update_all(&mut self) -> Result<()> {
        let keys = self.inputs.keys().cloned().collect::<Vec<_>>();
        for input in keys {
            self.update(&input)?;
        }

        Ok(())
    }
}

const NOTICE: &str = "this file was generated by nixpins (https://github.com/juliamertz/nixpins)";

impl Pins {
    pub fn emit(&self) -> String {
        use crate::emit::Node;

        let mut args: Vec<_> = self
            .sources
            .values()
            .filter(|v| !matches!(v, Fetcher::Flake(_)))
            .map(|v| Node::Identifier(v.function_name().into()))
            .collect::<HashSet<_>>()
            .into_iter()
            .collect();
        args.push(Node::Ellipsis);

        let inputs: Vec<Node> = self
            .inputs
            .iter()
            .map(|(name, value)| {
                if value.flake.is_some() {
                    Node::assign(
                        Node::Identifier(name.into()),
                        Node::Attrset(vec![
                            Node::assign(
                                Node::Identifier("url".into()),
                                Node::String(value.url.fmt().unwrap()),
                            ),
                            Node::assign(
                                Node::Identifier("flake".into()),
                                Node::Identifier(format!("{:?}", value.flake.unwrap_or_default())),
                            ),
                        ]),
                    )
                } else {
                    Node::assign(
                        Node::Attrpath(vec![name.to_owned(), "url".into()]),
                        Node::String(value.url.fmt().unwrap()),
                    )
                }
            })
            .collect();

        let sources: Vec<Node> = self
            .sources
            .iter()
            .map(|(name, value)| Node::assign(Node::Identifier(name.into()), value.node()))
            .collect();

        let nodes = vec![
            Node::assign(
                Node::Identifier("inputs".into()),
                Node::Attrset(inputs.clone()),
            ),
            Node::assign(Node::ident("sources"), Node::Attrset(sources)),
        ];

        let helpers = r#"
          fetchFlake = attrs: builtins.getFlake "${attrs.url}/${attrs.rev}";
        "#;

        let mut root = vec![
            Node::Comment(NOTICE.to_string()),
            Node::lambda(Node::Attrlist(args)),
        ];

        if self.inputs.iter().any(|(_, i)| i.flake.unwrap_or_default()) {
            root.push(Node::Let(vec![Node::Raw(helpers.into())]));
        }
        root.push(Node::Attrset(nodes));

        let mut buf = String::new();
        let ctx = crate::emit::Context::default();

        for node in root {
            buf += &node.emit(ctx);
            buf += "\n"
        }

        buf
    }

    pub fn read_from_file(filepath: impl AsRef<Path>) -> Result<Pins> {
        let content = std::fs::read_to_string(filepath.as_ref())?;
        let stripped = strip_arguments(&content);
        let stubbed = format!("{}\n{}", include_str!("stubs.nix"), stripped);
        let de = match tvix_serde::from_str(&stubbed) {
            Ok(value) => value,
            Err(err) => anyhow::bail!("Unable to deserialize pins, error: {err:#}"),
        };
        Ok(de)
    }

    pub fn write_to_file(&self, filepath: impl AsRef<Path>) -> Result<()> {
        std::fs::write(filepath, self.emit())?;
        Ok(())
    }
}

/// Strip anything from pins.nix expression that is not the main data structure
fn strip_arguments(code: &str) -> String {
    let mut buf = code.to_string();

    let re = Regex::new(r"#.*\n").unwrap();
    buf = re.replace(&buf, |_: &Captures| "").to_string();

    let re = Regex::new(r"\{.*\}:").unwrap();
    buf = re.replace(&buf, |_: &Captures| "").to_string();

    let re = Regex::new(r"let(.*\n)*in").unwrap();
    buf = re.replace(&buf, |_: &Captures| "").to_string();

    buf.trim().to_string()
}
