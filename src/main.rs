mod fetcher;
mod prefetch;

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use fetcher::Fetcher;
use serde::{Deserialize, Serialize};
use std::{
    collections::{HashMap, HashSet},
    fs,
    io::Write,
    path::{Path, PathBuf},
    process::Stdio,
};

/// Data structure of pins.nix
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct Pins {
    #[serde(serialize_with = "ordered_map")]
    pub inputs: HashMap<String, String>,

    #[serde(serialize_with = "ordered_map")]
    pub sources: HashMap<String, Fetcher>,
}

impl Pins {
    fn add(&mut self, url: String, name: Option<String>) -> Result<()> {
        let name = name.unwrap_or(package_name_from_url(&url));
        if self.inputs.contains_key(&name) {
            anyhow::bail!("Pin already exists of name '{name}'")
        }

        self.inputs.insert(name.clone(), url.clone());
        log::info!("Adding new input {name} with url {url}");

        let fetcher = Fetcher::from_url(&url)?;
        log::info!("Added {name} at revision {rev}", rev = fetcher.rev());
        self.sources.insert(name, fetcher);
        Ok(())
    }

    fn remove(&mut self, name: &str) {
        if self.inputs.remove(name).is_some() {
            log::info!("Removed input for {name}");
        }
        if self.sources.remove(name).is_some() {
            log::info!("Removed source for {name}");
        }
    }

    fn update(&mut self, name: &str) -> Result<()> {
        log::info!("Updating {name}...");
        let input = match self.inputs.get(name) {
            Some(pin) => pin,
            None => {
                anyhow::bail!("No pin found of name {name}");
            }
        };

        let fetcher = Fetcher::from_url(input)?;
        if let Some(prev_fetcher) = self.sources.get(name) {
            if prev_fetcher == &fetcher {
                log::info!("Nothing to do.")
            } else {
                log::info!(
                    "updated {name} to new version:\n  rev = '{rev}'\n  hash = '{hash}'",
                    rev = fetcher.rev(),
                    hash = fetcher.hash()
                )
            }
        }

        self.sources.insert(name.to_string(), fetcher);
        Ok(())
    }

    fn update_all(&mut self) -> Result<()> {
        let keys = self.inputs.keys().cloned().collect::<Vec<_>>();
        for input in keys {
            self.update(&input)?;
        }

        Ok(())
    }

    fn read_from_file(filepath: impl AsRef<Path>) -> Result<Self> {
        let content = fs::read_to_string(filepath.as_ref())?;
        let stubbed = &format!(
            "{}\n{}",
            include_str!("stubs.nix"),
            strip_arguments(&content)
        );

        let de = match serde_nix::from_str(stubbed) {
            Ok(value) => value,
            Err(err) => anyhow::bail!("Unable to deserialize pins, error: {err:#}"),
        };
        Ok(de)
    }

    fn write_to_file(&self, filepath: impl AsRef<Path>) -> Result<()> {
        let mut content = String::new();
        content.push_str(
            "# this file was generated by nixpins (https://github.com/juliamertz/nixpins)\n",
        );
        // add nixpkgs fetcher arguments
        content.push_str("{ ");
        let used_fetchers = unique_fetchers(self);
        for f in used_fetchers {
            content.push_str(&f);
            content.push_str(", ");
        }
        content.push_str("... }:\n");

        content.push_str(&serde_nix::to_string(self)?);

        let formatted = nixfmt(&content)?;
        fs::write(filepath, formatted)?;
        Ok(())
    }
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Source to operate on
    #[arg(default_value = "pins.nix")]
    file: PathBuf,

    #[arg(short, long)]
    dry: bool,

    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Create a new pins.nix in the current directory
    Init,

    /// Show pins and their versions
    Show {
        /// Name of pin
        #[arg(short, long)]
        name: Option<String>,
    },

    /// Add a new pin
    Add {
        /// Input url
        url: String,

        /// Name to addres this pin by
        #[arg(short, long)]
        name: Option<String>,
    },

    /// Remove a pin
    Remove {
        /// Pin name
        name: String,
    },

    /// Update pin sources
    Update {
        /// Name of pin to update
        name: Option<String>,
    },
}

pub fn main() -> Result<()> {
    colog::init();
    let args = Cli::parse();

    match args.command {
        Command::Init => {
            let pins = Pins::default();
            pins.write_to_file(&args.file)?;
        }

        Command::Show { .. } => {
            if !&args.file.exists() {
                anyhow::bail!("Cannot find {:?} in current directory", &args.file);
            }

            let pins = Pins::read_from_file(&args.file)?;
            for (key, _pin) in pins.inputs.iter() {
                match pins.sources.get(key) {
                    Some(source) => log::info!(
                        "{key}:\n  rev = '{rev}'\n  hash = '{hash}'",
                        rev = source.rev(),
                        hash = source.hash()
                    ),
                    None => log::warn!(
                        "Missing source for {key} run '{package_name} update' to fix this",
                        package_name = env!("CARGO_PKG_NAME")
                    ),
                };
            }
        }
        Command::Add { url, name } => {
            if !&args.file.exists() {
                anyhow::bail!("Cannot find {:?} in current directory", &args.file);
            }

            let mut pins = Pins::read_from_file(&args.file)?;
            pins.add(url, name)?;
            if !args.dry {
                pins.write_to_file(&args.file)?;
            }
        }

        Command::Remove { name } => {
            if !&args.file.exists() {
                anyhow::bail!("Cannot find {:?} in current directory", &args.file);
            }

            let mut pins = Pins::read_from_file(&args.file)?;
            pins.remove(&name);
            if !args.dry {
                pins.write_to_file(&args.file)?;
            }
        }
        Command::Update { name } => {
            if !&args.file.exists() {
                anyhow::bail!("Cannot find {:?} in current directory", &args.file);
            }

            let mut pins = Pins::read_from_file(&args.file)?;
            match name {
                Some(ref name) => pins.update(name)?,
                None => pins.update_all()?,
            }
            if !args.dry {
                pins.write_to_file(&args.file)?;
            }
        }
    }

    Ok(())
}

/// Collect list of unique fetcher names to be used as arguments
fn unique_fetchers(pins: &Pins) -> Vec<String> {
    let mut used_fetchers = HashSet::new();
    for (_, fetcher) in pins.sources.iter() {
        match fetcher {
            Fetcher::Github { .. } => used_fetchers.insert("fetchFromGitHub".to_string()),
            Fetcher::Gitlab { .. } => used_fetchers.insert("fetchFromGitLab".to_string()),
        };
    }
    let mut used_fetchers = used_fetchers.into_iter().collect::<Vec<_>>();
    used_fetchers.sort();
    used_fetchers
}

/// Strip anything from pins.nix expression that is not the main data structure
fn strip_arguments(code: &str) -> String {
    let code = code
        .lines()
        .filter(|line| !line.trim().starts_with("#"))
        .map(|line| format!("{line}\n"))
        .collect::<String>();
    let start = code.find(':').expect("Valid sources file");
    code[start + 1..code.len() - 1].to_string()
}

fn package_name_from_url(url: &str) -> String {
    url.split("/").last().expect("valid url").replace(".", "-")
}

/// Format code with nixfmt in PATH
pub fn nixfmt(code: &str) -> Result<String> {
    let mut child = std::process::Command::new("nixfmt")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .context("expected nixfmt to be in PATH")?;

    let child_stdin = child.stdin.as_mut().context("expected stdin")?;
    child_stdin.write_all(code.as_bytes())?;

    let output = child.wait_with_output()?;
    Ok(String::from_utf8(output.stdout)?)
}

/// For use with serde's [serialize_with] attribute
fn ordered_map<S, K: Ord + Serialize, V: Serialize>(
    value: &HashMap<K, V>,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let ordered: std::collections::BTreeMap<_, _> = value.iter().collect();
    ordered.serialize(serializer)
}
